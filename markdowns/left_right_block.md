和leftblock以及rightblock相关
======

## block的递推_old

最开始的第一个block和单个格子上的基是一样的，|phi^1> = |s^1>，然后给他扩展一个格子，变成 |phi^1, s^2> (|s^1, s^2>)  
然后第二个block，|phi^2>是|phi^1, s^2>的某种组合，这个组合的系数除了要满足正交（|phi^2>中的基两两要正交）归一以外，  
还要满足每个|phi^2>有确定的粒子数，这点哈密顿量和密度矩阵都是能保证的。

在程序中实现的算符的递推和书中略有不同的是，书中用的是\<m,j|OP|n,k> = \<m|O|n>\<j|P|k>，程序里是先把算符提升，  
\<m,j|OP|n,k> = sum_{p,q}{\<m,j|O x I|p, q>\<p,q|I x P|n,k>这时右边p需要等于n，q需要等与j，结果还是\<m|O|n>\<j|P|k>。  
这样做的好处是程序更加简单，只要矩阵乘法就能实现。  

增加了一个格子的-Block叫做-BlockExtend。将-BlockExtend组合成下一个-Block时，需要一个矩阵，他  
的每一行是一个新的基，列中是其在-BlockExtend中的分量，这之中也是会有很多零的，因为只有粒子数相同  
的可以重新组合，程序中会检查粒子数。

