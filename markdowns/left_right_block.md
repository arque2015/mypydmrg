和leftblock以及rightblock相关
======

## block的递推

最开始的第一个block和单个格子上的基是一样的，|phi^1> = |s^1>，然后给他扩展一个格子，变成 |phi^1, s^2> (|s^1, s^2>)  
然后第二个block，|phi^2>是|phi^1, s^2>的某种组合，这个组合的系数除了要满足正交（|phi^2>中的基两两要正交）归一以外，  
还要满足每个|phi^2>有确定的粒子数，这点哈密顿量和密度矩阵都是能保证的。

在进行superblock的计算的时候，是直接从<i|P|j>和<l|Q|m>构造的，<i,l|PQ|j,m> = <i|P|j><l|Q|m>  
但是有些时候Q在P前面，这个时候程序中的代码是不支持的，需要调整一下。  
如果是hopping项，这个时候不需要特意处理，因为C^+_iC_j和C^+_jC_i是转置的关系，  
直接使用转置位置上的数值就行了，可以让P在前面。  

增加了一个格子的-Block叫做-BlockExtend。将-BlockExtend组合成下一个-Block时，需要一个矩阵，他  
的每一行是一个新的基，列中是其在-BlockExtend中的分量，这之中也是会有很多零的，因为只有粒子数相同  
的可以重新组合，程序中会检查粒子数。

